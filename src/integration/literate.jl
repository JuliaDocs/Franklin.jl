const LITERATE_JULIA_FENCE   = "```julia"
const LITERATE_JULIA_FENCE_L = length(LITERATE_JULIA_FENCE)
const LITERATE_JULIA_FENCE_R = Regex(LITERATE_JULIA_FENCE)

"""
$SIGNATURES

Take a markdown string generated by literate and post-process it to number each code block
and mark them as eval-ed ones.
"""
function literate_post_process(s::String)::String
    isempty(s) && return s
    em   = eachmatch(LITERATE_JULIA_FENCE_R, s)
    buf  = IOBuffer()
    head = 1
    c    = 1
    for m in em
        write(buf, SubString(s, head, prevind(s, m.offset)))
        write(buf, "```julia:ex$c\n")
        head = nextind(s, m.offset + LITERATE_JULIA_FENCE_L)
        c   += 1
    end
    lis = lastindex(s)
    head < lis && write(buf, SubString(s, head, lis))
    return String(take!(buf))
end


"""
$SIGNATURES

Take a Literate.jl script and transform it into a JuDoc-markdown file.
"""
function literate_to_judoc(fpath::String)::String
    outpath = joinpath(PATHS[:assets], "literate")
    isdir(outpath) || mkdir(outpath)
    # don't show infos
    Logging.disable_logging(Logging.LogLevel(Logging.Info))
    markdown(fpath, outpath, documenter=false,
             postprocess=literate_post_process, credit=false)
    # bring back logging
    Logging.disable_logging(Logging.LogLevel(Logging.Debug))
    fname = splitdir(fpath)[2]
    return joinpath(outpath, splitext(fname)[1] * ".md")
end
